[case test695SimpleTypeAlias]
type MyInt = int

def f(x: MyInt) -> MyInt:
    return reveal_type(x)  # N: Revealed type is "builtins.int"

f(1)
f('')  # E: Argument 1 to "f" has incompatible type "str"; expected "int"

[case test695UnionTypeAlias]
type MyUnion = int | str

def f(x: MyUnion) -> MyUnion:
    return reveal_type(x)  # N: Revealed type is "Union[builtins.int, builtins.str]"

f(1)
f('')
f(()) # E: Argument 1 to "f" has incompatible type "Tuple[()]"; expected "Union[int, str]"
[builtins fixtures/tuple.pyi]

[case test695TupleTypeAlias]
type MyTuple = tuple[int, str]

def f(x: MyTuple) -> MyTuple:
    return reveal_type(x)  # N: Revealed type is "Tuple[builtins.int, builtins.str]"

f((1, 'x'))
f(1) # E: Argument 1 to "f" has incompatible type "int"; expected "Tuple[int, str]"
[builtins fixtures/tuple.pyi]

[case test695CallableTypeAlias]
from typing import Callable

type MyCallable = Callable[[int], None]

f: MyCallable
f(1)
f('') # E: Argument 1 has incompatible type "str"; expected "int"

[case test695ListTypeAlias]
type MyList = list[int]

def f(x: MyList) -> MyList:
    return reveal_type(x)  # N: Revealed type is "builtins.list[builtins.int]"

f([1])
f(['x']) # E: List item 0 has incompatible type "str"; expected "int"
[builtins fixtures/list.pyi]

[case test695AnyTypeAlias]
from typing import Any

type MyAny = Any

def f(x: MyAny) -> MyAny:
    x.foo()
    return reveal_type(x)  # N: Revealed type is "Any"

f(1)
f('x')

[case test695NoReturnTypeAlias]
from typing import NoReturn

type Never = NoReturn
a: Never

def f(a: Never): ...
f(5)  # E: Argument 1 to "f" has incompatible type "int"; expected "NoReturn"

[case test695ImportUnionAlias]
from _m import MyUnion

def f(x: MyUnion) -> MyUnion:
    return reveal_type(x)  # N: Revealed type is "Union[builtins.int, builtins.str]"

f(1)
f('x')
f(()) # E: Argument 1 to "f" has incompatible type "Tuple[()]"; expected "Union[int, str]"

[file _m.py]
type MyUnion = int | str
[builtins fixtures/tuple.pyi]

[case test695ProhibitReassigningAliases]
type A = float

if int():
    type A = int  # E: Name "A" already defined on line 1

[case test695ForwardTypeAlias]
def f(p: 'Alias') -> None:
    pass

reveal_type(f)  # N: Revealed type is "def (p: builtins.int)"
type Alias = int

[case test695TypeAliasInBuiltins]
def f(x: int): pass
type bytes = int
f(1)

[case test695GenericTypeAlias]
type MyList[T] = list[T]

def g(x: MyList[int]) -> MyList[int]:
    return reveal_type(x)  # N: Revealed type is "builtins.list[builtins.int]"

[case test695ForwardTypeAliasGeneric]
from typing import TypeVar, Tuple

def f(p: 'Alias[str]') -> None:
    pass

reveal_type(f)  # N: Revealed type is "def (p: Tuple[builtins.int, builtins.str])"
type Alias[T] = Tuple[int, T]
[builtins fixtures/tuple.pyi]

[case test695ProhibitTraditionalTypeVariableInAliasExpr]
from typing import TypeVar

T = TypeVar("T")
type MyList = list[T]  # E: Type variable "T" is not allowed in type alias expressions

[case testRecursiveAliasesErrors1]
from typing import Type, Callable, Union

def test() -> None:
    A = Union[A, int]  # E: Cannot resolve name "A" (possible cyclic definition) \
                       # N: Recursive types are not allowed at function scope
    B = Callable[[B], int]  # E: Cannot resolve name "B" (possible cyclic definition) \
                            # N: Recursive types are not allowed at function scope
    C = Type[C]  # E: Cannot resolve name "C" (possible cyclic definition) \
                 # N: Recursive types are not allowed at function scope

[case test695Class]
class MyGen[T]:  # E: PEP 695 generics are not yet supported
    def __init__(self, x: T) -> None:  # E: Name "T" is not defined
        self.x = x

def f(x: MyGen[int]):  # E: "MyGen" expects no type arguments, but 1 given
    reveal_type(x.x)  # N: Revealed type is "Any"

[case test695Function]
def f[T](x: T) -> T:  # E: PEP 695 generics are not yet supported \
                      # E: Name "T" is not defined
    return reveal_type(x)  # N: Revealed type is "Any"

reveal_type(f(1))  # N: Revealed type is "Any"

async def g[T](x: T) -> T:  # E: PEP 695 generics are not yet supported \
                            # E: Name "T" is not defined
    return reveal_type(x)  # N: Revealed type is "Any"

reveal_type(g(1))  # E: Value of type "Coroutine[Any, Any, Any]" must be used \
                   # N: Are you missing an await? \
                   # N: Revealed type is "typing.Coroutine[Any, Any, Any]"

[case test695TypeVar]
from typing import Callable
type Alias1[T: int] = list[T]  # E: PEP 695 type aliases are not yet supported
type Alias2[**P] = Callable[P, int]  # E: PEP 695 type aliases are not yet supported \
                                     # E: Value of type "int" is not indexable \
                                     # E: Name "P" is not defined
type Alias3[*Ts] = tuple[*Ts]  # E: PEP 695 type aliases are not yet supported \
                               # E: Name "Ts" is not defined

class Cls1[T: int]: ...  # E: PEP 695 generics are not yet supported
class Cls2[**P]: ...  # E: PEP 695 generics are not yet supported
class Cls3[*Ts]: ...  # E: PEP 695 generics are not yet supported

def func1[T: int](x: T) -> T: ...  # E: PEP 695 generics are not yet supported
def func2[**P](x: Callable[P, int]) -> Callable[P, str]: ...  # E: PEP 695 generics are not yet supported \
                                                              # E: The first argument to Callable must be a list of types, parameter specification, or "..." \
                                                              # N: See https://mypy.readthedocs.io/en/stable/kinds_of_types.html#callable-types-and-lambdas \
                                                              # E: Name "P" is not defined
def func3[*Ts](x: tuple[*Ts]) -> tuple[int, *Ts]: ...  # E: PEP 695 generics are not yet supported \
                                                       # E: Name "Ts" is not defined
[builtins fixtures/tuple.pyi]
